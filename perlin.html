<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Perlin Noise Examples (2D & 3D)</title>
  <style>
    body { background: #111; color: #ddd; font-family: sans-serif; margin: 0; padding: 0; }
    h1, h2 { text-align: center; }
    canvas { display: block; margin: 20px auto; border: 1px solid #333; }
  </style>
</head>
<body>
<h1>Perlin Noise Examples</h1>

<h2>2D Canvas: Fire, Mountains, Clouds</h2>
<canvas id="fireCanvas" width="400" height="400"></canvas>
<canvas id="mountainCanvas" width="400" height="400"></canvas>
<canvas id="cloudCanvas" width="400" height="400"></canvas>

<h2>3D Three.js: Mountains, Clouds</h2>
<div id="threeDContainer" style="width:100%; height:500px;"></div>

<script>
// === Simple Perlin Noise implementation ===
const Perlin = {
  grad: new Array(512),
  perm: new Array(512),

  init: function() {
    for (let i = 0; i < 256; i++) {
      this.grad[i] = Math.random() * 2 - 1;
      this.perm[i] = i;
    }
    for (let i = 0; i < 256; i++) {
      let j = Math.floor(Math.random() * 256);
      [this.perm[i], this.perm[j]] = [this.perm[j], this.perm[i]];
    }
    for (let i = 0; i < 256; i++) {
      this.perm[i + 256] = this.perm[i];
      this.grad[i + 256] = this.grad[i];
    }
  },

  fade: function(t) { return t * t * t * (t * (t * 6 - 15) + 10); },
  lerp: function(a, b, t) { return a + t * (b - a); },

  noise: function(x, y = 0, z = 0) {
    let X = Math.floor(x) & 255,
        Y = Math.floor(y) & 255,
        Z = Math.floor(z) & 255;

    x -= Math.floor(x);
    y -= Math.floor(y);
    z -= Math.floor(z);

    let u = this.fade(x),
        v = this.fade(y),
        w = this.fade(z);

    let A = this.perm[X] + Y, AA = this.perm[A] + Z, AB = this.perm[A + 1] + Z,
        B = this.perm[X + 1] + Y, BA = this.perm[B] + Z, BB = this.perm[B + 1] + Z;

    return this.lerp(
      this.lerp(
        this.lerp(this.grad[AA], this.grad[BA], u),
        this.lerp(this.grad[AB], this.grad[BB], u),
        v
      ),
      this.lerp(
        this.lerp(this.grad[AA+1], this.grad[BA+1], u),
        this.lerp(this.grad[AB+1], this.grad[BB+1], u),
        v
      ),
      w
    );
  }
};
Perlin.init();

function generate2DNoise(ctx, type) {
  const w = ctx.canvas.width;
  const h = ctx.canvas.height;
  const imgData = ctx.createImageData(w, h);
  let scale = type === 'fire' ? 0.05 : type === 'mountain' ? 0.01 : 0.02;

  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      let value = Perlin.noise(x * scale, y * scale);
      value = (value + 1) / 2; // normalize 0-1

      let i = (y * w + x) * 4;

      if (type === 'fire') {
        imgData.data[i] = 255;
        imgData.data[i+1] = value * 128;
        imgData.data[i+2] = 0;
      } else if (type === 'mountain') {
        let grey = value * 255;
        imgData.data[i] = imgData.data[i+1] = imgData.data[i+2] = grey;
      } else if (type === 'cloud') {
        let grey = value * 255;
        imgData.data[i] = imgData.data[i+1] = imgData.data[i+2] = grey;
      }
      imgData.data[i+3] = 255;
    }
  }

  ctx.putImageData(imgData, 0, 0);
}

generate2DNoise(document.getElementById('fireCanvas').getContext('2d'), 'fire');
generate2DNoise(document.getElementById('mountainCanvas').getContext('2d'), 'mountain');
generate2DNoise(document.getElementById('cloudCanvas').getContext('2d'), 'cloud');

</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r150/three.min.js"></script>
<script>
// === 3D Three.js Perlin noise terrain ===
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / 500, 0.1, 1000);
const renderer = new THREE.WebGLRenderer();
const container = document.getElementById('threeDContainer');
renderer.setSize(window.innerWidth, 500);
container.appendChild(renderer.domElement);

const geometry = new THREE.PlaneGeometry(100, 100, 100, 100);
const material = new THREE.MeshBasicMaterial({color: 0x6699ff, wireframe: true});
const plane = new THREE.Mesh(geometry, material);
scene.add(plane);

plane.rotation.x = -Math.PI / 2;

for (let i = 0; i < geometry.attributes.position.count; i++) {
  let x = geometry.attributes.position.getX(i);
  let y = geometry.attributes.position.getY(i);
  let z = Perlin.noise(x * 0.1, y * 0.1) * 10;
  geometry.attributes.position.setZ(i, z);
}
geometry.computeVertexNormals();

camera.position.set(0, 30, 30);
camera.lookAt(0, 0, 0);

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();

</script>

</body>
</html>
